import cProfile


def func1(n):
    a = [0] * 8
    for j in range(2, 10):
        num = 0
        for i in range(2, n + 1):
            if i % j == 0:
                num += 1
        a[j - 2] = num


def func2(n):
    a = [0] * 8
    for i in range(2, 10):
        a[i - 2] = n // i


# функция для нахождения кол-ва чисел, которые в данном проомежутке(2..n) деляется на i
def func3(n, i, Sum):
    if n == 1:
        return Sum
    if n % i == 0:
        Sum += 1
    return func3(n - 1, i, Sum)


# решение с помощью рекурсии, запускаем в основном блоке цикл от 2 до 10, и с помощью функции 3 находим
# кол-во  решений
def main4(n):
    a = [0] * 8
    for i in range(2, 10):
        a[i - 2] = func3(n, i, 0)

# "les_4_task_1.func1(99)"
# 1000 loops, best of 5: 66.1 usec per loop

# "les_4_task_1.func1(990)"
# 1000 loops, best of 5: 722 usec per loop

# "les_4_task_1.func1(5000)"
# 1000 loops, best of 5: 3.89 msec per loop

# "les_4_task_1.func2(99)"
# 1000 loops, best of 5: 1.29 usec per loop

# "les_4_task_1.func2(990)"
# 1000 loops, best of 5: 1.33 usec per loop

# "les_4_task_1.func2(5000)"
# 1000 loops, best of 5: 1.39 usec per loop

# "les_4_task_1.main4(99)"
# 1000 loops, best of 5: 191 usec per loop

# "les_4_task_1.main4(990)"
# 1000 loops, best of 5: 2.26 msec per loop

# "les_4_task_1.main4(5000)"
# Вызвало ошибку переполнения стека функции


# cProfile.run('func1(100)')
# 1    0.000    0.000    0.000    0.000 les_4_task_3.py:4(func1)
# cProfile.run('func1(990)')
# 1    0.001    0.001    0.001    0.001 les_4_task_3.py:4(func1)
# cProfile.run('func1(5000)')
# 1    0.004    0.004    0.004    0.004 les_4_task_3.py:4(func1)


# cProfile.run('func2(100)')
# 1    0.000    0.000    0.000    0.000 les_4_task_3.py:14(func2)
# cProfile.run('func2(990)')
# 1    0.000    0.000    0.000    0.000 les_4_task_3.py:14(func2)
# cProfile.run('func2(5000)')
# 1    0.000    0.000    0.000    0.000 les_4_task_3.py:14(func2)

# cProfile.run('main4(100)')
# 800/8    0.001    0.000    0.001    0.000 les_4_task_3.py:20(func3)
# 1    0.000    0.000    0.001    0.001 les_4_task_3.py:28(main4)

# cProfile.run('main4(990)')
# 7920/8    0.004    0.000    0.004    0.001 les_4_task_3.py:20(func3)
# 1    0.000    0.000    0.004    0.004 les_4_task_3.py:28(main4)

# cProfile.run('main4(5000)')
# Ошибка переполнения стека рекурсии


# Проанализоровав время работы трех вариантов решения данной задачи можно сделать пару выводов.

# 1) Метод решения 3 (main4 и func3)
# данной задачи с использованием функции мало того, что занимает много времени, так и помимо того он еще и
# использовать рекурсию, что может привести у перепонению стека рекурсии, а значит данный вариант решения является не
# приемлимым для данной задачи

# 2) Метод решения 2 (func 1)
# показанный в решении домашнего задания, 3 урока является более оптимальным,
# чем предыдущий, но все равно не идеальным, так как использует вложенные циклы, что занимает время, и время работы
# алгоритма увеличивается линейно
#
# 3) Метод решения 1 (func 2)
# если немного подумать и вспомнить математику, можно понять, что кол-во чисел,
# которые кратны i на промежутке от 2 до n, будет равно n // i, таким образом, мы не используя вложенных циклов нашли
# искомое количество одним делением, и остается только пробежаться по массиву перебирая все значения i и деля n на i.
# Как итог время работы программы, почти не зависит от n, что делает код самым оптимальным


